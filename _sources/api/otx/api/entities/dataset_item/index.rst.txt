:py:mod:`otx.api.entities.dataset_item`
=======================================

.. py:module:: otx.api.entities.dataset_item

.. autoapi-nested-parse::

   This module implements the dataset item entity.



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   otx.api.entities.dataset_item.DatasetItemEntity




Attributes
~~~~~~~~~~

.. autoapisummary::

   otx.api.entities.dataset_item.logger


.. py:data:: logger
   

   

.. py:class:: DatasetItemEntity(media: otx.api.entities.media.IMedia2DEntity, annotation_scene: otx.api.entities.annotation.AnnotationSceneEntity, roi: Optional[otx.api.entities.annotation.Annotation] = None, metadata: Optional[List[otx.api.entities.metadata.MetadataItemEntity]] = None, subset: otx.api.entities.subset.Subset = Subset.NONE, ignored_labels: Optional[Union[List[otx.api.entities.label.LabelEntity], Tuple[otx.api.entities.label.LabelEntity, Ellipsis], Set[otx.api.entities.label.LabelEntity]]] = None)

   DatasetItemEntity represents an item in the DatasetEntity.

   It holds a media item, annotation and an ROI. The ROI determines the region of interest for the dataset item, and
   is described by a shape entity.

   The fundamental properties of a dataset item are:

   - A 2d media entity (e.g. Image)
   - A 2d annotation entity for the full resolution media entity
   - An ROI, describing the region of interest.
   - The subset it belongs to
   - Metadata for the media entity (e.g. saliency map or active score)
   - A list of labels to ignore

   .. rubric:: Getting data from dataset item

   The first step is to fetch the input data for the network.

   >>> dataset_item = DatasetItemEntity()
   >>> media_numpy = dataset_item.numpy  # RGB media data (Height, Width, Channels)

   This returns the numpy data for the assigned ROI. But it is possible to extract any arbitrary region.

   >>> from otx.api.entities.shapes.rectangle import Rectangle
   >>> top_left_quart_roi = Annotation(Rectangle(x1=0.0, y1=0.0, x2=0.5, y2=0.5), labels=[])
   >>> top_left_quart_numpy = dataset_item.roi_numpy(roi=top_left_quart_roi)

   Get the subset of labels for the item ROI:

   >>> labels = dataset_item.get_roi_labels(labels=...)

   Get the annotations __visible__ in the ROI:

   >>> dataset_item.get_annotations()

   .. rubric:: Adding output data to dataset item

   It is possible to add shapes or just labels for the ROI.

   Add shapes to dataset item:

   >>> box = Rectangle(x1=0.2, y1=0.3, x2=0.6, y2=0.5)
   >>> dataset_item.append_annotations(annotations=[Annotation(box, labels=[...])])

   Add labels to ROI:

   >>> dataset_item.append_labels(labels=[...])

   :param media: Media item
   :type media: IMedia2DEntity
   :param annotation_scene: Annotation scene
   :type annotation_scene: AnnotationSceneEntity
   :param roi: Region Of Interest
   :type roi: Optional[Annotation]
   :param metadata: Metadata attached to dataset item
   :type metadata: Optional[List[MetadataItemEntity]]
   :param subset: `Subset` for item. E.g. `Subset.VALIDATION`
   :type subset: Subset
   :param ignored_labels: Collection of
                          labels that should be ignored in this dataset item. For instance, in a training scenario, this parameter is
                          used to ignore certain labels within the existing annotations because their status becomes uncertain
                          following a label schema change.
   :type ignored_labels: Optional[Union[List[LabelEntity], Tuple[LabelEntity, ...], Set[LabelEntity]]]

   .. py:method:: set_metadata(metadata: List[otx.api.entities.metadata.MetadataItemEntity])

      Sets the metadata.


   .. py:method:: get_metadata() -> List[otx.api.entities.metadata.MetadataItemEntity]

      Returns the metadata.


   .. py:method:: ignored_labels() -> Set[otx.api.entities.label.LabelEntity]
      :property:

      Get the IDs of the labels to ignore in this dataset item.


   .. py:method:: __repr__()

      String representation of the dataset item.


   .. py:method:: roi() -> otx.api.entities.annotation.Annotation
      :property:

      Region Of Interest.


   .. py:method:: subset() -> otx.api.entities.subset.Subset
      :property:

      Returns the subset that the IDatasetItem belongs to. e.g. Subset.TRAINING.


   .. py:method:: media() -> otx.api.entities.media.IMedia2DEntity
      :property:

      Media.


   .. py:method:: roi_numpy(roi: Optional[otx.api.entities.annotation.Annotation] = None) -> numpy.ndarray

      Gives the numpy data for the media, given an ROI.

      This function allows to take a crop of any arbitrary region of the media in the Dataset entity.
      If the ROI is not given, the ROI assigned to the DatasetItem will be used as default.

      :param roi: Shape entity. The shape will be converted if needed, to extract the ROI numpy.
      :type roi: Optional[Annotation]

      :returns: Numpy array with media data
      :rtype: np.ndarray


   .. py:method:: numpy() -> numpy.ndarray
      :property:

      Returns the numpy data for the media, taking ROI into account.

      :returns: Numpy array. RGB array of shape (Height, Width, Channels)
      :rtype: np.ndarrray


   .. py:method:: width() -> int
      :property:

      The width of the dataset item, taking into account the ROI.


   .. py:method:: height() -> int
      :property:

      The height of the dataset item, taking into account the ROI.


   .. py:method:: annotation_scene() -> otx.api.entities.annotation.AnnotationSceneEntity
      :property:

      Access to annotation scene.


   .. py:method:: get_annotations(labels: Optional[List[otx.api.entities.label.LabelEntity]] = None, include_empty: bool = False, include_ignored: bool = False) -> List[otx.api.entities.annotation.Annotation]

      Returns a list of annotations that exist in the dataset item (wrt. ROI).

      This is done by checking that the center of the annotation is located in the ROI.

      :param labels: Subset of input labels to filter with; if ``None``, all the shapes within
                     the ROI are returned.
      :type labels: Optional[LabelEntity]
      :param include_empty: if True, returns both empty and non-empty labels
      :type include_empty: bool
      :param include_ignored: if True, includes the labels in ignored_labels
      :type include_ignored: bool

      :returns: The intersection of the input label set and those present within the ROI
      :rtype: List[Annotation]


   .. py:method:: append_annotations(annotations: Sequence[otx.api.entities.annotation.Annotation])

      Adds a list of shapes to the annotation.


   .. py:method:: get_roi_labels(labels: Optional[List[otx.api.entities.label.LabelEntity]] = None, include_empty: bool = False, include_ignored: bool = False) -> List[otx.api.entities.label.LabelEntity]

      Return the subset of the input labels which exist in the dataset item (wrt. ROI).

      :param labels: Subset of input labels to filter with; if ``None``, all the labels
                     within the ROI are returned.
      :type labels: Optional[List[LabelEntity]]
      :param include_empty: if True, returns both empty and non-empty labels
      :type include_empty: bool
      :param include_ignored: if True, includes the labels in ignored_labels
      :type include_ignored: bool

      :returns: The intersection of the input label set and those present within the ROI.
      :rtype: List[LabelEntity]


   .. py:method:: get_shapes_labels(labels: Optional[List[otx.api.entities.label.LabelEntity]] = None, include_empty: bool = False, include_ignored: bool = False) -> List[otx.api.entities.label.LabelEntity]

      Get the labels of the shapes present in this dataset item.

      if a label list is supplied, only labels present within that list are returned. if include_empty is True,
      present empty labels are returned as well.

      :param labels: if supplied only labels present in this list are returned.
                     Defaults to None.
      :type labels: Optional[List[LabelEntity]]
      :param include_empty: if True, returns both empty and non-empty labels. Defaults to False.
      :type include_empty: bool
      :param include_ignored: if True, includes the labels in ignored_labels. Defaults to False.
      :type include_ignored: bool

      :returns: a list of labels from the shapes within the roi of this dataset item
      :rtype: List[LabelEntity]


   .. py:method:: append_labels(labels: List[otx.api.entities.scored_label.ScoredLabel])

      Appends labels to the DatasetItem and adds it to the the annotation label as well if it's not yet there.

      :param labels: list of labels to be appended.
      :type labels: List[ScoredLabel]


   .. py:method:: __eq__(other)

      Compares if two DatasetItems are equal.

      :param other: other DatasetItem to compare with.
      :type other: "DatasetItems"

      :returns: True if equal, False otherwise.
      :rtype: bool


   .. py:method:: __deepcopy__(memo)

      Avoids copying the lock and unintentional ID sharing among AnnotationSceneEntity instances.

      When we deepcopy this object, be sure not to deep copy the lock, as this is not possible,
      make a new lock instead. In addition, we prevent deepcopy of AnnotationSceneEntity member
      variable to avoid unintentional ID sharing among instances. Same instance reference is
      copied to the output instead.


   .. py:method:: append_metadata_item(data: otx.api.entities.metadata.IMetadata, model: Optional[otx.api.entities.model.ModelEntity] = None)

      Appends metadata produced by some model to the dataset item.

      .. rubric:: Adding visualization heatmap (ResultMediaEntity) to DatasetItemEntity

      >>> from otx.api.entities.image import Image
      >>> from otx.api.entities.result_media import ResultMediaEntity
      >>> media = Image(file_path='image.jpeg')
      >>> annotation = NullAnnotationSceneEntity()
      >>> dataset_item = DatasetItem(media=media, annotation_scene=annotation)
      >>> data = np.ones((120, 120, 3)).astype(np.uint8) * 255 # Saliency numpy
      >>> result_media = ResultMediaEntity(name="Gradcam++",
      ...                                  type="Gradcam++",
      ...                                  annotation_scene=annotation,
      ...                                  numpy=data)
      >>> dataset_item.append_metadata_item(result_media)

      .. rubric:: Representation vector for active learning

      >>> from otx.api.entities.tensor import TensorEntity
      >>> tensor = TensorEntity(name="representation_vector", numpy=data)
      >>> dataset_item.append_metadata_item(data=tensor, model=model)

      :param data: any object of a class inherited from IMetadata. (e.g., FloatMetadata, Tensor)
      :type data: IMetadata
      :param model: model that was used to generated metadata
      :type model: Optional[ModelEntity]


   .. py:method:: get_metadata_by_name_and_model(name: str, model: Optional[otx.api.entities.model.ModelEntity]) -> Sequence[otx.api.entities.metadata.MetadataItemEntity]

      Returns a metadata item with `name` and generated by `model`.

      :param name: the name of the metadata
      :type name: str
      :param model: the model which was used to generate the metadata.
      :type model: Optional[ModelEntity]

      :returns: a list of metadata items with `name` and generated by `model`.
      :rtype: Sequence[MetadataItemEntity]



